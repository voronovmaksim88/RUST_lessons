// ============================================================================
//                    БИТОВЫЕ ОПЕРАЦИИ В RUST
// ============================================================================
// Битовые (поразрядные) операции работают с числами на уровне отдельных битов.
// Они очень быстрые и используются в:
// - Низкоуровневом программировании (драйверы, микроконтроллеры)
// - Работе с флагами и масками
// - Оптимизации вычислений
// - Криптографии
// - Компьютерной графике
// - Сетевых протоколах (работа с IP-адресами, портами)
// ============================================================================

fn main() {
    println!("╔══════════════════════════════════════════════════════════════╗");
    println!("║           БИТОВЫЕ ОПЕРАЦИИ В RUST                            ║");
    println!("╚══════════════════════════════════════════════════════════════╝\n");

    // ========================================================================
    // 1. ДВОИЧНОЕ ПРЕДСТАВЛЕНИЕ ЧИСЕЛ
    // ========================================================================
    // В Rust можно записывать числа в двоичном формате с префиксом 0b
    // Подчёркивания _ используются для визуального разделения (игнорируются компилятором)

    println!("═══ 1. ДВОИЧНОЕ ПРЕДСТАВЛЕНИЕ ЧИСЕЛ ═══\n");

    let decimal = 42; // Десятичное число
    let binary = 0b101010; // То же число в двоичном формате
    let hex = 0x2A; // То же число в шестнадцатеричном формате
    let octal = 0o52; // То же число в восьмеричном формате

    println!("Число 42 в разных системах счисления:");
    println!("  Десятичное:          {}", decimal);
    println!("  Двоичное (0b101010): {}", binary);
    println!("  Hex (0x2A):          {}", hex);
    println!("  Восьмеричное (0o52): {}", octal);

    // Форматирование вывода в разных системах счисления:
    // {:b} - двоичная, {:x} - hex (маленькие буквы), {:X} - hex (большие), {:o} - восьмеричная
    println!("\nЧисло 255 в разных форматах:");
    println!("  Десятичное:      {:>10}", 255);
    println!("  Двоичное:        {:>10b}", 255);
    println!("  Hex:             {:>10x}", 255);
    println!("  Восьмеричное:    {:>10o}", 255);

    // Форматирование с ведущими нулями
    println!("\nФорматирование с ведущими нулями (число 5):");
    println!("  8-бит двоичное:  {:08b}", 5_u8); // 00000101
    println!("  16-бит двоичное: {:016b}", 5_u16); // 0000000000000101

    // ========================================================================
    // 2. ПОБИТОВОЕ И (AND) - оператор &
    // ========================================================================
    // Возвращает 1 только если ОБА бита равны 1
    //
    // Таблица истинности:
    //   A | B | A & B
    //   0 | 0 |   0
    //   0 | 1 |   0
    //   1 | 0 |   0
    //   1 | 1 |   1
    //
    // Применение: проверка флагов, маскирование битов, проверка чётности

    println!("\n═══ 2. ПОБИТОВОЕ И (AND) - оператор & ═══\n");

    let a: u8 = 0b1100_1010; // 202 в десятичной
    let b: u8 = 0b1010_1100; // 172 в десятичной
    let result_and = a & b;

    println!("Побитовое И (AND):");
    println!("  a       = {:08b} ({})", a, a);
    println!("  b       = {:08b} ({})", b, b);
    println!("  a & b   = {:08b} ({})", result_and, result_and);
    println!("            ────────");
    println!("  Пояснение: бит = 1 только там, где ОБА бита = 1");

    // Практический пример: проверка, установлен ли конкретный бит
    let value: u8 = 0b0101_0110;
    let mask: u8 = 0b0000_0100; // Маска для проверки 3-го бита (справа, с нуля считая - бит №2)

    println!("\nПроверка установки бита:");
    println!("  value = {:08b}", value);
    println!("  mask  = {:08b} (проверяем бит №2)", mask);

    if value & mask != 0 {
        println!(
            "  Результат: бит №2 УСТАНОВЛЕН (value & mask = {:08b})",
            value & mask
        );
    } else {
        println!("  Результат: бит №2 НЕ установлен");
    }

    // Проверка чётности числа
    let number = 42;
    println!("\nПроверка чётности числа {}:", number);
    println!("  {} & 1 = {}", number, number & 1);
    if number & 1 == 0 {
        println!("  Число {} ЧЁТНОЕ (младший бит = 0)", number);
    } else {
        println!("  Число {} НЕЧЁТНОЕ (младший бит = 1)", number);
    }

    // ========================================================================
    // 3. ПОБИТОВОЕ ИЛИ (OR) - оператор |
    // ========================================================================
    // Возвращает 1 если ХОТЯ БЫ ОДИН бит равен 1
    //
    // Таблица истинности:
    //   A | B | A | B
    //   0 | 0 |   0
    //   0 | 1 |   1
    //   1 | 0 |   1
    //   1 | 1 |   1
    //
    // Применение: установка флагов, объединение битовых масок

    println!("\n═══ 3. ПОБИТОВОЕ ИЛИ (OR) - оператор | ═══\n");

    let a: u8 = 0b1100_0011;
    let b: u8 = 0b0011_1100;
    let result_or = a | b;

    println!("Побитовое ИЛИ (OR):");
    println!("  a       = {:08b} ({})", a, a);
    println!("  b       = {:08b} ({})", b, b);
    println!("  a | b   = {:08b} ({})", result_or, result_or);
    println!("            ────────");
    println!("  Пояснение: бит = 1, если ХОТЯ БЫ ОДИН из битов = 1");

    // Практический пример: установка конкретного бита
    let mut flags: u8 = 0b0000_0000;
    println!("\nУстановка битов (флагов):");
    println!("  Начальное значение: {:08b}", flags);

    flags = flags | 0b0000_0001; // Устанавливаем бит 0
    println!("  После | 0b0000_0001: {:08b} (установили бит 0)", flags);

    flags = flags | 0b0000_0100; // Устанавливаем бит 2
    println!("  После | 0b0000_0100: {:08b} (установили бит 2)", flags);

    flags = flags | 0b1000_0000; // Устанавливаем бит 7
    println!("  После | 0b1000_0000: {:08b} (установили бит 7)", flags);

    // ========================================================================
    // 4. ПОБИТОВОЕ ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) - оператор ^
    // ========================================================================
    // Возвращает 1 если биты РАЗЛИЧАЮТСЯ
    //
    // Таблица истинности:
    //   A | B | A ^ B
    //   0 | 0 |   0
    //   0 | 1 |   1
    //   1 | 0 |   1
    //   1 | 1 |   0
    //
    // Особенности XOR:
    // - A ^ A = 0 (любое число XOR само с собой = 0)
    // - A ^ 0 = A (XOR с нулём не меняет число)
    // - A ^ B ^ B = A (двойной XOR возвращает исходное значение)
    //
    // Применение: переключение битов, шифрование, обмен значениями без временной переменной

    println!("\n═══ 4. ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) - оператор ^ ═══\n");

    let a: u8 = 0b1100_1010;
    let b: u8 = 0b1010_1100;
    let result_xor = a ^ b;

    println!("Побитовое XOR:");
    println!("  a       = {:08b} ({})", a, a);
    println!("  b       = {:08b} ({})", b, b);
    println!("  a ^ b   = {:08b} ({})", result_xor, result_xor);
    println!("            ────────");
    println!("  Пояснение: бит = 1, если биты РАЗЛИЧАЮТСЯ");

    // Свойство: A ^ A = 0
    let x: u8 = 0b1010_1010;
    println!("\nСвойство: A ^ A = 0");
    println!("  {:08b} ^ {:08b} = {:08b}", x, x, x ^ x);

    // Свойство: A ^ 0 = A
    println!("\nСвойство: A ^ 0 = A");
    println!("  {:08b} ^ {:08b} = {:08b}", x, 0_u8, x ^ 0);

    // Практический пример: переключение (toggle) бита
    let mut toggle: u8 = 0b0000_1111;
    let toggle_mask: u8 = 0b0000_0100;

    println!("\nПереключение бита (toggle):");
    println!("  Исходное значение: {:08b}", toggle);
    toggle = toggle ^ toggle_mask;
    println!(
        "  После XOR с маской {:08b}: {:08b} (бит 2 выключен)",
        toggle_mask, toggle
    );
    toggle = toggle ^ toggle_mask;
    println!(
        "  После повторного XOR:        {:08b} (бит 2 снова включен)",
        toggle
    );

    // Обмен значениями без временной переменной (XOR swap)
    let mut x = 10;
    let mut y = 25;
    println!("\nОбмен значениями через XOR (XOR swap):");
    println!("  До:    x = {}, y = {}", x, y);
    x = x ^ y;
    y = x ^ y;
    x = x ^ y;
    println!("  После: x = {}, y = {}", x, y);
    println!("  (Хотя в Rust проще: (x, y) = (y, x) или std::mem::swap)");

    // Простое шифрование XOR
    let secret: u8 = 42;
    let key: u8 = 123;
    let encrypted = secret ^ key;
    let decrypted = encrypted ^ key;

    println!("\nПростое XOR-шифрование:");
    println!("  Секрет:       {} ({:08b})", secret, secret);
    println!("  Ключ:         {} ({:08b})", key, key);
    println!("  Зашифровано:  {} ({:08b})", encrypted, encrypted);
    println!("  Расшифровано: {} ({:08b})", decrypted, decrypted);

    // ========================================================================
    // 5. ПОБИТОВОЕ НЕ (NOT) - оператор !
    // ========================================================================
    // Инвертирует все биты: 0 становится 1, 1 становится 0
    //
    // Таблица истинности:
    //   A | !A
    //   0 |  1
    //   1 |  0
    //
    // ВАЖНО: результат зависит от типа данных (u8, u16, u32 и т.д.)

    println!("\n═══ 5. ПОБИТОВОЕ НЕ (NOT) - оператор ! ═══\n");

    let a: u8 = 0b0000_1111;
    let not_a = !a;

    println!("Побитовое NOT:");
    println!("  a  = {:08b} ({})", a, a);
    println!("  !a = {:08b} ({})", not_a, not_a);
    println!("       ────────");
    println!("  Пояснение: все биты инвертируются");

    // Влияние типа данных на результат NOT
    println!("\nВлияние типа данных на NOT:");
    let val_u8: u8 = 1;
    let val_u16: u16 = 1;
    let val_u32: u32 = 1;

    println!("  !1_u8  = {:8} = {:08b}", !val_u8, !val_u8);
    println!("  !1_u16 = {:8} = {:016b}", !val_u16, !val_u16);
    println!("  !1_u32 = {:8} = {:032b}", !val_u32, !val_u32);

    // Практический пример: создание маски для сброса бита
    let clear_bit_2: u8 = !0b0000_0100; // Маска для сброса бита 2
    println!("\nСоздание маски для сброса бита:");
    println!("  Исходная маска:     {:08b}", 0b0000_0100_u8);
    println!("  Инвертированная:    {:08b}", clear_bit_2);
    println!("  Теперь можно использовать & для сброса бита 2");

    // ========================================================================
    // 6. СДВИГ ВЛЕВО - оператор <<
    // ========================================================================
    // Сдвигает все биты влево на указанное количество позиций
    // Справа добавляются нули, биты слева теряются (выходят за пределы)
    //
    // Математический смысл: сдвиг влево на n = умножение на 2^n
    // A << n = A * 2^n
    //
    // Применение: быстрое умножение на степени двойки, создание масок

    println!("\n═══ 6. СДВИГ ВЛЕВО (<<) ═══\n");

    let a: u8 = 0b0000_0001;
    println!("Сдвиг влево:");
    println!("  a      = {:08b} ({})", a, a);
    println!("  a << 1 = {:08b} ({}) — умножили на 2", a << 1, a << 1);
    println!("  a << 2 = {:08b} ({}) — умножили на 4", a << 2, a << 2);
    println!("  a << 3 = {:08b} ({}) — умножили на 8", a << 3, a << 3);
    println!("  a << 4 = {:08b} ({}) — умножили на 16", a << 4, a << 4);

    // Переполнение при сдвиге
    let b: u8 = 0b1000_0000; // 128
    println!("\nПереполнение при сдвиге:");
    println!("  b      = {:08b} ({})", b, b);
    println!(
        "  b << 1 = {:08b} ({}) — старший бит потерян!",
        b << 1,
        b << 1
    );

    // Практический пример: быстрое умножение
    let number = 5;
    println!("\nБыстрое умножение на степени двойки:");
    println!("  {} * 2  = {} (через << 1)", number, number << 1);
    println!("  {} * 4  = {} (через << 2)", number, number << 2);
    println!("  {} * 8  = {} (через << 3)", number, number << 3);
    println!("  {} * 16 = {} (через << 4)", number, number << 4);

    // Создание битовых масок
    println!("\nСоздание масок для отдельных битов:");
    for i in 0..8 {
        let mask: u8 = 1 << i;
        println!("  Бит {}: 1 << {} = {:08b}", i, i, mask);
    }

    // ========================================================================
    // 7. СДВИГ ВПРАВО - оператор >>
    // ========================================================================
    // Сдвигает все биты вправо на указанное количество позиций
    //
    // Для беззнаковых типов (u8, u16, u32...): слева добавляются нули
    // Для знаковых типов (i8, i16, i32...): слева добавляется знаковый бит (арифметический сдвиг)
    //
    // Математический смысл: сдвиг вправо на n = деление на 2^n (с округлением вниз)
    // A >> n = A / 2^n
    //
    // Применение: быстрое деление на степени двойки, извлечение битовых полей

    println!("\n═══ 7. СДВИГ ВПРАВО (>>) ═══\n");

    let a: u8 = 0b1000_0000; // 128
    println!("Сдвиг вправо (беззнаковый):");
    println!("  a      = {:08b} ({})", a, a);
    println!("  a >> 1 = {:08b} ({}) — разделили на 2", a >> 1, a >> 1);
    println!("  a >> 2 = {:08b} ({}) — разделили на 4", a >> 2, a >> 2);
    println!("  a >> 3 = {:08b} ({}) — разделили на 8", a >> 3, a >> 3);

    // Потеря битов при сдвиге
    let b: u8 = 0b0000_0101; // 5
    println!("\nПотеря битов при сдвиге:");
    println!("  b      = {:08b} ({})", b, b);
    println!(
        "  b >> 1 = {:08b} ({}) — младший бит потерян, 5/2 = 2 (округление вниз)",
        b >> 1,
        b >> 1
    );

    // Разница между знаковым и беззнаковым сдвигом
    let unsigned: u8 = 0b1000_0000; // 128
    let signed: i8 = -128; // То же битовое представление, но со знаком

    println!("\nРазница знакового и беззнакового сдвига:");
    println!(
        "  u8:  {:08b} ({}) >> 2 = {:08b} ({})",
        unsigned,
        unsigned,
        unsigned >> 2,
        unsigned >> 2
    );
    println!(
        "  i8:  {:08b} ({}) >> 2 = {:08b} ({})",
        signed as u8,
        signed,
        (signed >> 2) as u8,
        signed >> 2
    );
    println!("  (Для i8 сохраняется знак — слева добавляются единицы)");

    // Практический пример: извлечение байтов из числа
    let big_number: u32 = 0xDEAD_BEEF;
    println!("\nИзвлечение байтов из числа 0x{:08X}:", big_number);
    println!("  Байт 0 (младший): 0x{:02X}", (big_number >> 0) & 0xFF);
    println!("  Байт 1:           0x{:02X}", (big_number >> 8) & 0xFF);
    println!("  Байт 2:           0x{:02X}", (big_number >> 16) & 0xFF);
    println!("  Байт 3 (старший): 0x{:02X}", (big_number >> 24) & 0xFF);

    // ========================================================================
    // 8. СОСТАВНЫЕ ОПЕРАТОРЫ ПРИСВАИВАНИЯ
    // ========================================================================
    // Rust поддерживает составные операторы для битовых операций:
    // &=  |=  ^=  <<=  >>=

    println!("\n═══ 8. СОСТАВНЫЕ ОПЕРАТОРЫ ПРИСВАИВАНИЯ ═══\n");

    let mut value: u8 = 0b0000_0000;
    println!("Демонстрация составных операторов:");
    println!("  Начальное значение: {:08b}", value);

    value |= 0b0000_1111; // Установить младшие 4 бита
    println!("  После |= 0b0000_1111: {:08b} (установили биты)", value);

    value &= 0b1111_0011; // Сбросить биты 2 и 3
    println!("  После &= 0b1111_0011: {:08b} (сбросили биты 2,3)", value);

    value ^= 0b0000_0001; // Переключить бит 0
    println!("  После ^= 0b0000_0001: {:08b} (переключили бит 0)", value);

    value <<= 2; // Сдвиг влево на 2
    println!("  После <<= 2:          {:08b} (сдвиг влево)", value);

    value >>= 1; // Сдвиг вправо на 1
    println!("  После >>= 1:          {:08b} (сдвиг вправо)", value);

    // ========================================================================
    // 9. ПРАКТИЧЕСКИЕ ПРИМЕРЫ И ИДИОМЫ
    // ========================================================================

    println!("\n═══ 9. ПРАКТИЧЕСКИЕ ПРИМЕРЫ И ИДИОМЫ ═══\n");

    // --- 9.1 Работа с битовыми флагами ---
    println!("9.1 Работа с битовыми флагами:");

    // Определяем флаги как константы (степени двойки)
    const FLAG_READ: u8 = 1 << 0; // 0b0000_0001 = 1
    const FLAG_WRITE: u8 = 1 << 1; // 0b0000_0010 = 2
    const FLAG_EXECUTE: u8 = 1 << 2; // 0b0000_0100 = 4
    const FLAG_HIDDEN: u8 = 1 << 3; // 0b0000_1000 = 8

    let mut permissions: u8 = 0;

    // Установка флагов
    permissions |= FLAG_READ;
    permissions |= FLAG_WRITE;
    println!("  Установили READ и WRITE: {:08b}", permissions);

    // Установка нескольких флагов одновременно
    permissions |= FLAG_EXECUTE | FLAG_HIDDEN;
    println!("  Добавили EXECUTE и HIDDEN: {:08b}", permissions);

    // Проверка флага
    if permissions & FLAG_WRITE != 0 {
        println!("  Флаг WRITE установлен!");
    }

    // Сброс флага
    permissions &= !FLAG_HIDDEN;
    println!("  Сбросили HIDDEN: {:08b}", permissions);

    // Переключение флага
    permissions ^= FLAG_EXECUTE;
    println!("  Переключили EXECUTE: {:08b}", permissions);

    // --- 9.2 Подсчёт установленных битов (population count) ---
    println!("\n9.2 Подсчёт установленных битов:");

    let number: u32 = 0b1011_0110_1111_0001;
    let count = number.count_ones(); // Встроенный метод Rust
    println!("  Число {:016b} содержит {} единичных битов", number, count);
    println!("  Нулевых битов: {}", number.count_zeros());

    // --- 9.3 Поиск позиции битов ---
    println!("\n9.3 Поиск позиции битов:");

    let value: u32 = 0b0000_1000_0100_0000;
    println!("  Число: {:016b}", value);
    println!("  Ведущих нулей: {}", value.leading_zeros());
    println!("  Завершающих нулей: {}", value.trailing_zeros());
    println!("  Позиция младшей единицы: {}", value.trailing_zeros());

    // --- 9.4 Проверка, является ли число степенью двойки ---
    println!("\n9.4 Проверка на степень двойки:");

    fn is_power_of_two(n: u32) -> bool {
        n != 0 && (n & (n - 1)) == 0
    }

    for n in [0, 1, 2, 3, 4, 7, 8, 15, 16, 17] {
        let result = is_power_of_two(n);
        let builtin = if n > 0 { n.is_power_of_two() } else { false };
        println!(
            "  {} — степень двойки? {} (встроенный метод: {})",
            n, result, builtin
        );
    }

    // --- 9.5 Округление до ближайшей степени двойки ---
    println!("\n9.5 Округление до степени двойки:");

    for n in [5_u32, 7, 9, 15, 17, 100] {
        println!(
            "  {} -> {} (вверх), {} (вниз)",
            n,
            n.next_power_of_two(),
            if n.is_power_of_two() {
                n
            } else {
                1 << (31 - n.leading_zeros())
            }
        );
    }

    // --- 9.6 Реверс битов ---
    println!("\n9.6 Реверс битов:");

    let original: u8 = 0b1100_0001;
    let reversed = original.reverse_bits();
    println!("  Исходное:     {:08b}", original);
    println!("  Реверс:       {:08b}", reversed);

    // --- 9.7 Циклический сдвиг (rotate) ---
    println!("\n9.7 Циклический сдвиг (биты не теряются):");

    let value: u8 = 0b1100_0011;
    println!("  Исходное:            {:08b}", value);
    println!("  Rotate left на 2:    {:08b}", value.rotate_left(2));
    println!("  Rotate right на 2:   {:08b}", value.rotate_right(2));

    // --- 9.8 Работа с цветами RGB ---
    println!("\n9.8 Работа с цветами RGB:");

    // Упаковка RGB в одно число (формат 0x00RRGGBB)
    let r: u32 = 255;
    let g: u32 = 128;
    let b: u32 = 64;

    let color: u32 = (r << 16) | (g << 8) | b;
    println!("  R={}, G={}, B={}", r, g, b);
    println!("  Упакованный цвет: 0x{:06X}", color);

    // Распаковка
    let extracted_r = (color >> 16) & 0xFF;
    let extracted_g = (color >> 8) & 0xFF;
    let extracted_b = color & 0xFF;
    println!(
        "  Распаковано: R={}, G={}, B={}",
        extracted_r, extracted_g, extracted_b
    );

    // --- 9.9 Маскирование IP-адреса ---
    println!("\n9.9 Маскирование IP-адреса:");

    // IP: 192.168.1.100
    let ip: u32 = (192 << 24) | (168 << 16) | (1 << 8) | 100;
    // Маска подсети: 255.255.255.0 (/24)
    let mask: u32 = 0xFF_FF_FF_00;
    // Адрес сети
    let network = ip & mask;

    println!(
        "  IP:      {}.{}.{}.{}",
        (ip >> 24) & 0xFF,
        (ip >> 16) & 0xFF,
        (ip >> 8) & 0xFF,
        ip & 0xFF
    );
    println!(
        "  Маска:   {}.{}.{}.{}",
        (mask >> 24) & 0xFF,
        (mask >> 16) & 0xFF,
        (mask >> 8) & 0xFF,
        mask & 0xFF
    );
    println!(
        "  Сеть:    {}.{}.{}.{}",
        (network >> 24) & 0xFF,
        (network >> 16) & 0xFF,
        (network >> 8) & 0xFF,
        network & 0xFF
    );

    // ========================================================================
    // 10. ВСТРОЕННЫЕ МЕТОДЫ ДЛЯ РАБОТЫ С БИТАМИ
    // ========================================================================

    println!("\n═══ 10. ВСТРОЕННЫЕ МЕТОДЫ RUST ДЛЯ РАБОТЫ С БИТАМИ ═══\n");

    let n: u32 = 0b0111_0011_0001_0000;

    println!("Число: {:016b} ({})", n, n);
    println!(
        "  count_ones()       = {} — количество единиц",
        n.count_ones()
    );
    println!(
        "  count_zeros()      = {} — количество нулей",
        n.count_zeros()
    );
    println!(
        "  leading_zeros()    = {} — ведущие нули",
        n.leading_zeros()
    );
    println!(
        "  trailing_zeros()   = {} — завершающие нули",
        n.trailing_zeros()
    );
    println!(
        "  leading_ones()     = {} — ведущие единицы",
        n.leading_ones()
    );
    println!(
        "  trailing_ones()    = {} — завершающие единицы",
        n.trailing_ones()
    );
    println!(
        "  reverse_bits()     = {:016b} — реверс битов",
        n.reverse_bits()
    );
    println!(
        "  swap_bytes()       = {:016b} — перестановка байтов",
        n.swap_bytes()
    );
    println!(
        "  rotate_left(4)     = {:016b} — циклический сдвиг влево",
        n.rotate_left(4)
    );
    println!(
        "  rotate_right(4)    = {:016b} — циклический сдвиг вправо",
        n.rotate_right(4)
    );
    println!(
        "  is_power_of_two()  = {} — степень двойки?",
        n.is_power_of_two()
    );
    println!(
        "  next_power_of_two()= {} — следующая степень двойки",
        n.next_power_of_two()
    );

    // ========================================================================
    // ЗАКЛЮЧЕНИЕ
    // ========================================================================

    println!("\n╔══════════════════════════════════════════════════════════════╗");
    println!("║                    КРАТКАЯ ШПАРГАЛКА                         ║");
    println!("╠══════════════════════════════════════════════════════════════╣");
    println!("║  &   — AND (оба бита = 1)         |   — OR (хотя бы один)   ║");
    println!("║  ^   — XOR (биты различаются)     !   — NOT (инверсия)      ║");
    println!("║  <<  — сдвиг влево (×2^n)         >>  — сдвиг вправо (÷2^n) ║");
    println!("╠══════════════════════════════════════════════════════════════╣");
    println!("║  Установить бит:   value |= (1 << n)                        ║");
    println!("║  Сбросить бит:     value &= !(1 << n)                       ║");
    println!("║  Переключить бит:  value ^= (1 << n)                        ║");
    println!("║  Проверить бит:    (value & (1 << n)) != 0                  ║");
    println!("╚══════════════════════════════════════════════════════════════╝");
}
