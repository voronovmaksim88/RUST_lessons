// ============================================================================
// БЕЗЫМЯННЫЕ ФУНКЦИИ (CLOSURES / ЗАМЫКАНИЯ) В RUST
// ============================================================================
// Безымянные функции (также называемые замыканиями или closures) — это
// анонимные функции, которые можно сохранять в переменных и передавать
// как аргументы другим функциям. Они могут "захватывать" переменные
// из окружающей области видимости.
// ============================================================================

fn main() {
    // ========================================================================
    // ПРИМЕР 1: БАЗОВЫЙ СИНТАКСИС ЗАМЫКАНИЙ
    // ========================================================================
    // Замыкание определяется с помощью вертикальных линий |параметры|
    // После параметров идёт тело функции в фигурных скобках (или без них
    // для однострочных выражений)

    // Замыкание без параметров
    let say_hello = || println!("Привет, мир!");
    say_hello(); // Вызов замыкания

    // Замыкание с одним параметром (тип можно указать явно)
    let square = |n: i32| {
        let result = n * n;
        println!("Квадрат числа {} равен {}", n, result);
    };
    square(4);
    square(5);

    // Замыкание с неявным типом параметра (Rust выведет тип автоматически)
    let double = |x| x * 2;
    println!("Удвоенное значение 10: {}", double(10));

    // ========================================================================
    // ПРИМЕР 2: ОДНОСТРОЧНЫЕ ЗАМЫКАНИЯ
    // ========================================================================
    // Если тело замыкания состоит из одного выражения, фигурные скобки
    // можно опустить. Результат выражения будет возвращён автоматически.

    let add = |a: i32, b: i32| a + b;
    let multiply = |a: i32, b: i32| a * b;
    let subtract = |a: i32, b: i32| a - b;

    println!("5 + 3 = {}", add(5, 3));
    println!("5 * 3 = {}", multiply(5, 3));
    println!("5 - 3 = {}", subtract(5, 3));

    // ========================================================================
    // ПРИМЕР 3: ЗАМЫКАНИЯ С ЯВНЫМ УКАЗАНИЕМ ВОЗВРАЩАЕМОГО ТИПА
    // ========================================================================
    // Возвращаемый тип указывается после стрелки ->

    let divide = |a: f64, b: f64| -> f64 {
        if b == 0.0 {
            println!("Ошибка: деление на ноль!");
            0.0 // Возвращаем 0.0 в случае ошибки
        } else {
            a / b
        }
    };

    println!("10.0 / 2.0 = {}", divide(10.0, 2.0));
    println!("10.0 / 0.0 = {}", divide(10.0, 0.0));

    // ========================================================================
    // ПРИМЕР 4: ЗАХВАТ ПЕРЕМЕННЫХ ИЗ ОКРУЖЕНИЯ (ГЛАВНАЯ ФИШКА ЗАМЫКАНИЙ!)
    // ========================================================================
    // Замыкания могут использовать переменные из внешней области видимости.
    // Это называется "захват" (capture). Существует три способа захвата:
    // 1. По ссылке (&T) - заимствование
    // 2. По изменяемой ссылке (&mut T) - изменяемое заимствование
    // 3. По значению (T) - перемещение владения

    // Захват по ссылке (заимствование) - по умолчанию
    let greeting = String::from("Привет");
    let greet = || {
        // greeting захватывается по ссылке, так как мы только читаем её
        println!("{}, пользователь!", greeting);
    };
    greet();
    // greeting всё ещё доступна здесь, так как была заимствована
    println!("Переменная greeting всё ещё доступна: {}", greeting);

    // Захват по изменяемой ссылке
    let mut counter = 0;
    let mut increment = || {
        // counter захватывается по изменяемой ссылке
        counter += 1;
        println!("Счётчик: {}", counter);
    };
    increment(); // Счётчик: 1
    increment(); // Счётчик: 2
    increment(); // Счётчик: 3
    // После завершения использования замыкания counter снова доступен
    println!("Финальное значение счётчика: {}", counter);

    // ========================================================================
    // ПРИМЕР 5: ПРИНУДИТЕЛЬНОЕ ПЕРЕМЕЩЕНИЕ С ПОМОЩЬЮ move
    // ========================================================================
    // Ключевое слово move заставляет замыкание взять владение всеми
    // захваченными переменными. Это особенно важно для многопоточности.

    let name = String::from("Алексей");

    // Без move замыкание захватило бы name по ссылке
    // С move замыкание забирает владение переменной name
    let print_name = move || {
        println!("Имя: {}", name);
        // name теперь принадлежит замыканию
    };

    print_name();
    // println!("{}", name); // ОШИБКА! name была перемещена в замыкание

    // ========================================================================
    // ПРИМЕР 6: ЗАМЫКАНИЯ КАК АРГУМЕНТЫ ФУНКЦИЙ
    // ========================================================================
    // Замыкания можно передавать в функции как аргументы.
    // Для этого используются трейты: Fn, FnMut, FnOnce

    // Функция, принимающая замыкание как аргумент
    fn apply_operation<F>(a: i32, b: i32, operation: F) -> i32
    where
        F: Fn(i32, i32) -> i32, // F должен реализовывать трейт Fn
    {
        operation(a, b)
    }

    let sum = apply_operation(10, 20, |x, y| x + y);
    let product = apply_operation(10, 20, |x, y| x * y);
    let max = apply_operation(10, 20, |x, y| if x > y { x } else { y });

    println!("Сумма: {}", sum);
    println!("Произведение: {}", product);
    println!("Максимум: {}", max);

    // ========================================================================
    // ПРИМЕР 7: ИСПОЛЬЗОВАНИЕ ЗАМЫКАНИЙ С ИТЕРАТОРАМИ
    // ========================================================================
    // Замыкания часто используются с методами итераторов: map, filter, fold и др.

    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // map - применяет замыкание к каждому элементу
    let squares: Vec<i32> = numbers
        .iter() // Создаём итератор
        .map(|x| x * x) // Применяем замыкание: возводим в квадрат
        .collect(); // Собираем результат в вектор
    println!("Квадраты чисел: {:?}", squares);

    // filter - оставляет только элементы, для которых замыкание вернёт true
    // Это "ленивый" адаптер итератора - он не выполняет работу, пока не вызван collect()
    let even_numbers: Vec<&i32> = numbers
        .iter() // Создаём итератор по ссылкам: Iterator<Item = &i32>
        .filter(|x| {
            // filter принимает замыкание с сигнатурой FnMut(&Self::Item) -> bool
            // Поскольку iter() даёт &i32, то x здесь имеет тип &&i32 (ссылка на ссылку)
            *x % 2 == 0 // Разыменовываем один раз (*x), чтобы получить &i32,
            // затем % автоматически разыменует &i32 до i32 для операции
            // Возвращаем true для чётных чисел (остаток от деления на 2 равен 0)
        })
        .collect(); // Собираем отфильтрованные элементы в Vec<&i32>
    // Тип Vec<&i32> указан явно, т.к. collect() может собирать в разные коллекции
    println!("Чётные числа: {:?}", even_numbers);

    // fold - "сворачивает" коллекцию в одно значение
    let sum_of_numbers: i32 = numbers.iter().fold(0, |accumulator, x| accumulator + x);
    //         ↑                   ↑
    //         |                   └── текущий элемент
    //         └── начальное значение аккумулятора
    println!("Сумма всех чисел: {}", sum_of_numbers);

    // Комбинирование нескольких методов в цепочку
    let result: i32 = numbers
        .iter()
        .filter(|x| *x % 2 == 1) // Берём только нечётные: 1, 3, 5, 7, 9
        .map(|x| x * 2) // Умножаем на 2: 2, 6, 10, 14, 18
        .fold(0, |acc, x| acc + x); // Суммируем: 50
    println!("Сумма удвоенных нечётных чисел: {}", result);

    // ========================================================================
    // ПРИМЕР 8: ЗАМЫКАНИЯ, ВОЗВРАЩАЮЩИЕ ЗАМЫКАНИЯ
    // ========================================================================
    // Функция может возвращать замыкание. Для этого нужно использовать
    // impl Fn(...) или Box<dyn Fn(...)>

    fn create_multiplier(factor: i32) -> impl Fn(i32) -> i32 {
        // Используем move, чтобы замыкание забрало владение factor
        move |x| x * factor
    }

    let triple = create_multiplier(3);
    let quintuple = create_multiplier(5);

    println!("3 * 7 = {}", triple(7)); // 21
    println!("5 * 7 = {}", quintuple(7)); // 35

    // ========================================================================
    // ПРИМЕР 9: РАЗНЫЕ ТИПЫ ЗАМЫКАНИЙ (Fn, FnMut, FnOnce)
    // ========================================================================
    // - Fn: замыкание, которое только читает захваченные переменные
    // - FnMut: замыкание, которое может изменять захваченные переменные
    // - FnOnce: замыкание, которое может быть вызвано только один раз
    //           (потребляет захваченные переменные)

    // Пример FnOnce - замыкание, которое потребляет захваченную переменную
    let message = String::from("Это сообщение будет потреблено");
    let consume_and_print = || {
        // drop() уничтожает переменную, забирая владение
        let consumed = message; // Перемещаем message внутрь замыкания
        println!("{}", consumed);
        // consumed уничтожается здесь
    };
    consume_and_print();
    // consume_and_print(); // ОШИБКА! Замыкание уже потребило message

    // ========================================================================
    // ПРИМЕР 10: ПРАКТИЧЕСКИЙ ПРИМЕР - СОЗДАНИЕ КАЛЬКУЛЯТОРА
    // ========================================================================

    // Структура для хранения операций
    struct Calculator {
        history: Vec<String>,
    }

    impl Calculator {
        fn new() -> Self {
            Calculator {
                history: Vec::new(),
            }
        }

        // Метод, принимающий замыкание для выполнения операции
        fn calculate<F>(&mut self, a: f64, b: f64, op_name: &str, operation: F) -> f64
        where
            F: Fn(f64, f64) -> f64,
        {
            let result = operation(a, b);
            self.history
                .push(format!("{} {} {} = {}", a, op_name, b, result));
            result
        }

        fn print_history(&self) {
            println!("\n=== История вычислений ===");
            for (i, entry) in self.history.iter().enumerate() {
                println!("{}. {}", i + 1, entry);
            }
        }
    }

    let mut calc = Calculator::new();

    // Используем разные замыкания для разных операций
    calc.calculate(10.0, 5.0, "+", |a, b| a + b);
    calc.calculate(10.0, 5.0, "-", |a, b| a - b);
    calc.calculate(10.0, 5.0, "*", |a, b| a * b);
    calc.calculate(
        10.0,
        5.0,
        "/",
        |a, b| if b != 0.0 { a / b } else { f64::NAN },
    );
    calc.calculate(2.0, 8.0, "^", |a, b| a.powf(b)); // Возведение в степень

    calc.print_history();

    // ========================================================================
    // ПРИМЕР 11: ЗАМЫКАНИЯ С НЕСКОЛЬКИМИ ОПЕРАТОРАМИ И ЛОКАЛЬНЫМИ ПЕРЕМЕННЫМИ
    // ========================================================================

    let complex_calculation = |x: i32, y: i32| -> i32 {
        // Внутри замыкания можно объявлять локальные переменные
        let step1 = x + y;
        let step2 = step1 * 2;
        let step3 = step2 - 10;

        // Можно использовать условия
        if step3 > 0 {
            step3 * step3
        } else {
            step3.abs()
        }
    };

    println!(
        "\nСложное вычисление для (5, 3): {}",
        complex_calculation(5, 3)
    );
    println!(
        "Сложное вычисление для (2, 1): {}",
        complex_calculation(2, 1)
    );

    // ========================================================================
    // ПРИМЕР 12: СОХРАНЕНИЕ ЗАМЫКАНИЙ В СТРУКТУРАХ
    // ========================================================================
    // Для хранения замыканий в структурах нужно использовать обобщённые типы
    // или Box<dyn Fn(...)>

    struct Validator<F>
    where
        F: Fn(&str) -> bool,
    {
        validation_fn: F,
        error_message: String,
    }

    impl<F> Validator<F>
    where
        F: Fn(&str) -> bool,
    {
        fn new(validation_fn: F, error_message: &str) -> Self {
            Validator {
                validation_fn,
                error_message: error_message.to_string(),
            }
        }

        fn validate(&self, input: &str) -> Result<(), &str> {
            if (self.validation_fn)(input) {
                Ok(())
            } else {
                Err(&self.error_message)
            }
        }
    }

    // Создаём валидатор с замыканием
    let email_validator = Validator::new(
        |s: &str| s.contains('@') && s.contains('.'),
        "Некорректный email адрес!",
    );

    println!("\nВалидация email:");
    match email_validator.validate("user@example.com") {
        Ok(()) => println!("user@example.com - Валидный!"),
        Err(e) => println!("user@example.com - {}", e),
    }
    match email_validator.validate("invalid-email") {
        Ok(()) => println!("invalid-email - Валидный!"),
        Err(e) => println!("invalid-email - {}", e),
    }

    // ========================================================================
    // ПРИМЕР 13: ЗАМЫКАНИЯ И Option/Result
    // ========================================================================
    // Замыкания часто используются с методами Option и Result

    let maybe_number: Option<i32> = Some(42);
    let no_number: Option<i32> = None;

    // map - применяет функцию к значению внутри Some
    let doubled = maybe_number.map(|x| x * 2);
    println!("\nOption::map: {:?}", doubled); // Some(84)

    // unwrap_or_else - возвращает значение или вычисляет замыкание для None
    let value = no_number.unwrap_or_else(|| {
        println!("Значение отсутствует, возвращаем значение по умолчанию");
        0
    });
    println!("Полученное значение: {}", value);

    // and_then - для цепочки операций, которые могут вернуть None
    let result = maybe_number
        .and_then(|x| if x > 0 { Some(x * 10) } else { None })
        .and_then(|x| Some(x + 1));
    println!("Результат цепочки: {:?}", result); // Some(421)

    // ========================================================================
    // РЕЗЮМЕ
    // ========================================================================
    // Замыкания в Rust - мощный инструмент, который позволяет:
    // 1. Создавать анонимные функции на лету
    // 2. Захватывать переменные из окружения
    // 3. Передавать логику как аргументы функций
    // 4. Работать с итераторами в функциональном стиле
    // 5. Создавать гибкие и переиспользуемые абстракции
    //
    // Синтаксис: |параметры| { тело } или |параметры| выражение
    // Типы: Fn (только чтение), FnMut (изменение), FnOnce (потребление)
    // ========================================================================

    println!("\n=== Все примеры выполнены успешно! ===");
}
