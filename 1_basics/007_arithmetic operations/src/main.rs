fn main() {
    // ============================================================
    // БАЗОВЫЕ АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ В RUST
    // ============================================================
    //
    // В этом примере мы рассмотрим:
    // 1. Простые арифметические операции (+, -, *, /, %)
    // 2. Особенности целочисленного и вещественного деления
    // 3. Операции с присваиванием (+=, -=, *=, /=, %=)
    // 4. Приоритет операторов и использование скобок
    // 5. Переполнение целых чисел (overflow)
    // 6. Комбинирование разных типов (приведение типов)
    //

    // ------------------------------------------------------------
    // 1. ПРОСТЫЕ ОПЕРАЦИИ С ЦЕЛЫМИ ЧИСЛАМИ
    // ------------------------------------------------------------
    let a: i32 = 12;
    let b: i32 = 6;

    // Сложение
    let sum = a + b;
    println!("{a} + {b} = {sum}"); // 12 + 6 = 18

    // Вычитание
    let difference = a - b;
    println!("{a} - {b} = {difference}"); // 12 - 6 = 6

    // Умножение
    let product = a * b;
    println!("{a} * {b} = {product}"); // 12 * 6 = 72

    // Деление (целочисленное)
    //
    // ВАЖНО:
    // - При делении целых чисел результат тоже целое число.
    // - Дробная часть просто отбрасывается (НЕ округляется).
    let quotient = a / b;
    println!("{a} / {b} = {quotient}"); // 12 / 6 = 2

    // Деление с отбрасыванием дробной части
    let x: i32 = 29;
    let y: i32 = 6;
    let integer_division = x / y;
    println!("{x} / {y} = {integer_division} (целочисленное деление)"); // 29 / 6 = 4

    // Остаток от деления (оператор %)
    //
    // Это то же самое, что "29 mod 6" в математике.
    // 29 = 4 * 6 + 5, значит остаток 5.
    let remainder = x % y;
    println!("{x} % {y} = {remainder} (остаток от деления)"); // 29 % 6 = 5

    println!(); // Пустая строка для разделения

    // ------------------------------------------------------------
    // 2. ОПЕРАЦИИ С ПРИСВАИВАНИЕМ
    // ------------------------------------------------------------
    //
    // Операторы вида +=, -=, *=, /=, %= — это краткая форма
    // для записи "переменная = переменная <операция> значение".
    //
    // Примеры ниже показывают, как изменяется значение переменной.

    let mut number: i32;

    // Присваивание после сложения (+=)
    number = 12;
    number += 6; // эквивалентно: number = number + 6;
    println!("12 += 6 → {}", number); // 18

    // Присваивание после вычитания (-=)
    number = 12;
    number -= 6; // number = number - 6;
    println!("12 -= 6 → {}", number); // 6

    // Присваивание после умножения (*=)
    number = 12;
    number *= 6; // number = number * 6;
    println!("12 *= 6 → {}", number); // 72

    // Присваивание после деления (/=)
    //
    // ВАЖНО: для целых чисел дробная часть отбрасывается.
    number = 29;
    number /= 6; // number = number / 6;
    println!("29 /= 6 → {} (целочисленное деление)", number); // 4

    // Присваивание после деления по модулю (%=)
    number = 29;
    number %= 6; // number = number % 6;
    println!("29 %= 6 → {} (остаток)", number); // 5

    println!(); // Пустая строка для разделения

    // ------------------------------------------------------------
    // 3. ВЕЩЕСТВЕННЫЕ ЧИСЛА (ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ)
    // ------------------------------------------------------------
    //
    // Для чисел с плавающей точкой (f32, f64) деление сохраняет дробную часть.

    let fa: f64 = 29.0;
    let fb: f64 = 6.0;
    let float_division = fa / fb;
    println!("{fa} / {fb} = {float_division}"); // 4.8333333333...

    // Форматированный вывод с 2 знаками после запятой
    println!("{fa} / {fb} (с форматированием) = {:.2}", float_division); // 4.83

    // Комбинация операций
    let float_expr = (fa + 1.0) * 0.5 - 3.2;
    println!("(29.0 + 1.0) * 0.5 - 3.2 = {}", float_expr);

    println!(); // Пустая строка для разделения

    // ------------------------------------------------------------
    // 4. ПРИОРИТЕТ ОПЕРАТОРОВ И СКОБКИ
    // ------------------------------------------------------------
    //
    // Приоритет (от более высокого к более низкому):
    // 1) Унарные операторы (-x)
    // 2) *, /, %
    // 3) +, -
    //
    // Скобки всегда задают явный порядок выполнения.

    let expr1 = 2 + 3 * 4; // сначала 3 * 4 = 12, затем 2 + 12 = 14
    let expr2 = (2 + 3) * 4; // сначала 2 + 3 = 5, затем 5 * 4 = 20

    println!("2 + 3 * 4 = {expr1}");
    println!("(2 + 3) * 4 = {expr2}");

    // Отрицательные числа (унарный минус)
    let neg = -5; // тип i32 выводится автоматически
    let expr3 = 10 + neg; // 10 + (-5) = 5
    println!("10 + (-5) = {}", expr3);

    println!(); // Пустая строка для разделения

    // ------------------------------------------------------------
    // 5. ПЕРЕПОЛНЕНИЕ ЦЕЛОГО ТИПА (INTEGER OVERFLOW)
    // ------------------------------------------------------------
    //
    // Целые типы (u8, i8, u16, i16, ...) имеют ограниченный диапазон.
    // Например:
    // - u8:  0..=255
    // - i8: -128..=127
    //
    // В режиме debug при переполнении программа паникнёт (panic!).
    // В release-режиме поведение по умолчанию — "зацикливание"
    // по модулю 2^N (но лучше не полагаться на это, а использовать
    // специальные методы вроде .wrapping_add()).
    //
    // Здесь мы покажем безопасный способ через методы.

    let max_u8: u8 = u8::MAX; // 255
    println!("Максимальное значение u8::MAX = {}", max_u8);

    // wrapping_add выполняет сложение по модулю 256
    let wrapped = max_u8.wrapping_add(1); // 255 + 1 → 0
    println!("u8::MAX.wrapping_add(1) = {}", wrapped);

    // checked_add возвращает Option:
    // - Some(результат), если нет переполнения
    // - None, если произошло переполнение
    let checked = max_u8.checked_add(1);
    println!("u8::MAX.checked_add(1) = {:?}", checked); // None

    println!(); // Пустая строка для разделения

    // ------------------------------------------------------------
    // 6. РАЗНЫЕ ЧИСЛОВЫЕ ТИПЫ И ПРИВЕДЕНИЕ ТИПОВ (CASTING)
    // ------------------------------------------------------------
    //
    // Rust не выполняет неявное приведение типов между разными
    // числовыми типами. Нужно явно указывать as.

    let int_number: i32 = 1000;
    let long_number: i64 = 500;

    // Нельзя напрямую сложить i32 и i64:
    // let combined = int_number + long_number; // ошибка компиляции
    //
    // Нужно явно привести тип:
    let combined_result = int_number as i64 + long_number;
    println!("1000 (i32) as i64 + 500 (i64) = {}", combined_result); // 1500

    // Пример с преобразованием в меньший тип
    let big_number: i32 = 300;
    let small_number: u8 = big_number as u8; // 300 % 256 = 44
    println!(
        "300 (i32) as u8 = {} (обрезание по модулю 256)",
        small_number
    );

    println!(); // Пустая строка для разделения

    // ------------------------------------------------------------
    // 7. ОПЕРАЦИИ С РАЗНЫМИ ЦЕЛОЧИСЛЕННЫМИ ТИПАМИ
    // ------------------------------------------------------------

    let byte_number: u8 = 100;
    let result_u8 = byte_number + 28; // тип результата тоже u8 (пока нет переполнения)
    println!("100 (u8) + 28 = {}", result_u8); // 128

    // Пример: вычисление среднего (целочисленного и вещественного)
    let v1: i32 = 5;
    let v2: i32 = 8;
    let int_avg = (v1 + v2) / 2; // целочисленное среднее: 13 / 2 = 6
    let float_avg = (v1 as f64 + v2 as f64) / 2.0; // вещественное: 13.0 / 2.0 = 6.5

    println!("Целочисленное среднее (5 и 8) = {}", int_avg);
    println!("Вещественное среднее (5 и 8) = {}", float_avg);

    println!(); // Пустая строка для разделения

    // ------------------------------------------------------------
    // 8. НЕБОЛЬШИЕ ПРАКТИЧЕСКИЕ ПРИМЕРЫ
    // ------------------------------------------------------------

    // 8.1. Перевод минут в часы и минуты
    let total_minutes: u32 = 130;
    let hours = total_minutes / 60;
    let minutes = total_minutes % 60;
    println!(
        "{} минут = {} час(ов) и {} минут(ы)",
        total_minutes, hours, minutes
    );

    // 8.2. Проверка чётности числа: n % 2 == 0
    let n: i32 = 17;
    let is_even = n % 2 == 0;
    println!("Число {n} чётное? {}", is_even);

    // 8.3. Расстояние (евклидова норма) для точки (x, y)
    let px: f64 = 3.0;
    let py: f64 = 4.0;
    let distance = (px * px + py * py).sqrt(); // sqrt() — метод f64
    println!("Расстояние от (0,0) до (3,4) = {}", distance); // 5

    // Конец примеров
}
