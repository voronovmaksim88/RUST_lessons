// ========================================================================
// ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ (floating-point)
// ========================================================================
// В Rust два типа с плавающей точкой: f32 и f64
// f64 — тип по умолчанию (двойная точность)

pub fn show() {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║        ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ (floating-point)               ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    // ═══════════════════════════════════════════════════════════════════
    // КАК РАБОТАЮТ ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ
    // ═══════════════════════════════════════════════════════════════════
    println!("═══ КАК РАБОТАЮТ ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ ═══\n");

    println!("Числа с плавающей точкой хранятся в формате IEEE 754");
    println!("Это стандарт для представления дробных чисел в компьютере.\n");

    println!("📐 Структура числа с плавающей точкой:");
    println!("  ┌─────────┬──────────┬──────────────────────────┐");
    println!("  │  ЗНАК   │ ПОРЯДОК  │       МАНТИССА           │");
    println!("  │ (sign)  │(exponent)│      (mantissa)          │");
    println!("  └─────────┴──────────┴──────────────────────────┘");
    println!();
    println!("  Формула: (-1)^знак × мантисса × 2^порядок");
    println!();

    println!("f32 (32 бита):");
    println!("  • 1 бит:  знак (+ или -)");
    println!("  • 8 бит:  порядок (экспонента)");
    println!("  • 23 бита: мантисса (значащие цифры)");
    println!("  ⇒ ~6-7 значащих десятичных цифр");
    println!();

    println!("f64 (64 бита):");
    println!("  • 1 бит:  знак (+ или -)");
    println!("  • 11 бит: порядок (экспонента)");
    println!("  • 52 бита: мантисса (значащие цифры)");
    println!("  ⇒ ~15-16 значащих десятичных цифр");
    println!();

    println!("💡 ДЕТАЛЬНЫЙ ПРИМЕР: как хранится число 12.5 в памяти");
    println!();
    println!("  ШАГ 1: Переводим 12.5 в двоичную систему");
    println!("    Целая часть: 12 = 8 + 4 = 2³ + 2² = 1100₂");
    println!("    Дробная часть: 0.5 = 1/2 = 0.1₂");
    println!("    Итого: 12.5₁₀ = 1100.1₂");
    println!();

    println!("  ШАГ 2: Нормализация (научная нотация)");
    println!("    1100.1₂ = 1.1001₂ × 2³");
    println!("    ↓");
    println!("    Сдвинули точку влево на 3 позиции");
    println!("    (получили форму 1.xxxx × 2ⁿ)");
    println!();

    println!("  ШАГ 3: Извлекаем компоненты для f32");
    println!();
    println!("    а) ЗНАК:");
    println!("       12.5 > 0, поэтому знак = 0 (положительное)");
    println!();

    println!("    б) ЭКСПОНЕНТА (порядок):");
    println!("       Реальная экспонента: 3");
    println!("       Смещение (bias) для f32: 127");
    println!("       Хранимая экспонента: 3 + 127 = 130₁₀ = 10000010₂");
    println!("       ↓");
    println!("       Смещение нужно, чтобы хранить отрицательные порядки");
    println!("       (например, 0.001 = 1.0 × 2⁻³ → экспонента = -3 + 127 = 124)");
    println!();

    println!("    в) МАНТИССА:");
    println!("       Из 1.1001₂ берём только дробную часть: .1001");
    println!("       (единица перед точкой не хранится - неявная!)");
    println!("       Дополняем нулями до 23 бит:");
    println!("       10010000000000000000000₂");
    println!();

    println!("  ШАГ 4: Собираем всё вместе (32 бита для f32)");
    println!("    ┌──────┬───────────────────┬──────────────────────────────────────────────────┐");
    println!("    │ ЗНАК │   ЭКСПОНЕНТА      │                  МАНТИССА                        │");
    println!("    │ (1)  │     (8 бит)       │                  (23 бита)                       │");
    println!("    ├──────┼───────────────────┼──────────────────────────────────────────────────┤");
    println!("    │  0   │  1 0 0 0 0 0 1 0  │ 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    │");
    println!("    │  +   │   (130 = 3+127)   │   (.1001 дробная часть от 1.1001)                │");
    println!("    └──────┴───────────────────┴──────────────────────────────────────────────────┘");
    println!();

    println!("  ПРОВЕРКА: Восстанавливаем число");
    println!("    (-1)⁰ × 1.1001₂ × 2³ = 1 × 1.5625 × 8 = 12.5 ✓");
    println!("    ↓       ↓            ↓");
    println!("    знак   мантисса     экспонента");
    println!();

    println!("  📝 Почему не хранится первая '1' в мантиссе?");
    println!("     В научной нотации всегда: 1.xxxxx × 2ⁿ");
    println!("     Первая единица всегда есть, её можно не хранить!");
    println!("     Это даёт +1 бит точности бесплатно 🎉");
    println!();

    println!("⚠️ ВАЖНО: Почему возникают погрешности?");
    println!("  1. Не все десятичные дроби можно точно представить в двоичной системе");
    println!("     Например: 0.1 в двоичной системе = 0.00011001100110011... (бесконечная дробь!)");
    println!();
    println!("  2. Ограниченная точность (только 23/52 бита для мантиссы)");
    println!("     Поэтому: 0.1 + 0.2 ≠ 0.3 (с точки зрения компьютера)");
    println!();
    println!("  3. Точность неравномерна:");
    println!("     • Около 0: очень высокая точность");
    println!("     • Около 1: максимальная точность");
    println!("     • Большие числа: точность снижается");
    println!();

    println!("Пример потери точности:");
    let a = 0.1;
    let b = 0.2;
    let c = a + b;
    println!("  let a = 0.1;");
    println!("  let b = 0.2;");
    println!("  let c = a + b;");
    println!("  println!(\"{{:.20}}\", c);");
    println!("  Результат: {:.20}", c);
    println!("  Ожидали:   0.30000000000000000000");
    println!("  Разница из-за двоичного представления!");
    println!();

    println!("─────────────────────────────────────────────────────────────────\n");

    // ═══════════════════════════════════════════════════════════════════
    // ОСНОВНЫЕ ТИПЫ f32 И f64
    // ═══════════════════════════════════════════════════════════════════
    println!("═══ ОСНОВНЫЕ ТИПЫ: f32 И f64 ═══\n");

    // f32: 32 бита, одинарная точность (~6-7 значащих цифр)
    let float_32: f32 = 3.141592;
    println!("f32: {}", float_32);
    println!("  Размер: {} байт", std::mem::size_of::<f32>());
    println!("  Точность: ~{} десятичных цифр", f32::DIGITS);

    // f64: 64 бита, двойная точность (~15-16 значащих цифр)
    // Это тип по умолчанию для чисел с плавающей точкой
    let float_64: f64 = 3.141592653589793;
    let default_float = 2.718281828; // Rust автоматически выберет f64
    println!("\nf64: {}", float_64);
    println!("  Размер: {} байт", std::mem::size_of::<f64>());
    println!("  Точность: ~{} десятичных цифр", f64::DIGITS);
    println!("  ⭐ Это тип по умолчанию для чисел с плавающей точкой!");
    println!("  По умолчанию: {}", default_float);

    // === ДЕМОНСТРАЦИЯ ТОЧНОСТИ ===
    println!("\n═══ Демонстрация точности ═══");

    // 1. Сравнение представления числа Пи
    let pi_f32: f32 = 3.141592653589793238;
    let pi_f64: f64 = 3.141592653589793238;
    println!("\nЧисло Пи (исходное: 3.141592653589793238):");
    println!("  f32: {:.20}", pi_f32);
    println!("  f64: {:.20}", pi_f64);
    println!("       ^^^^^^^^^^^^^^^^^ видна потеря точности у f32");

    // 2. Потеря точности при операциях
    let a_f32: f32 = 0.1 + 0.2;
    let a_f64: f64 = 0.1 + 0.2;
    println!("\n0.1 + 0.2:");
    println!("  f32: {:.20}", a_f32);
    println!("  f64: {:.20}", a_f64);
    println!("  Ожидалось: 0.30000000000000000000");
    println!("  💡 Это нормально для чисел с плавающей точкой!");

    // 3. Очень большие числа с дробной частью
    let big_f32: f32 = 16777216.0 + 0.5;
    let big_f64: f64 = 16777216.0 + 0.5;
    println!("\n16777216.0 + 0.5:");
    println!("  f32: {:.10}", big_f32);
    println!("  f64: {:.10}", big_f64);
    println!("  ⚠️ f32 теряет дробную часть на больших числах!");

    // 4. Константы точности
    println!("\n═══ Константы точности ═══");

    println!("\nЧто такое EPSILON:");
    println!("  EPSILON - это наименьшее положительное число, которое");
    println!("  при добавлении к 1.0 даёт результат, отличный от 1.0");
    println!("  Формула: 1.0 + EPSILON > 1.0");

    println!("\nf32::EPSILON: {:.15}", f32::EPSILON);
    let test_f32_yes = 1.0f32 + f32::EPSILON;
    let test_f32_no = 1.0f32 + (f32::EPSILON / 2.0);
    println!(
        "  1.0 + EPSILON =         {:.20} (отличается!)",
        test_f32_yes
    );
    println!(
        "  1.0 + (EPSILON / 2.0) = {:.20} (= 1.0, не хватило точности)",
        test_f32_no
    );

    println!("\nf64::EPSILON: {:.25}", f64::EPSILON);
    let test_f64_yes = 1.0f64 + f64::EPSILON;
    let test_f64_no = 1.0f64 + (f64::EPSILON / 2.0);
    println!(
        "  1.0 + EPSILON =         {:.25} (отличается!)",
        test_f64_yes
    );
    println!("  1.0 + (EPSILON / 2.0) = {:.25} (= 1.0)", test_f64_no);

    println!("\n💡 Использование EPSILON для сравнения:");
    println!("  ❌ НЕ делайте: if a == b");
    println!("  ✅ Делайте: if (a - b).abs() < EPSILON");

    let a: f64 = 0.1 + 0.2;
    let b: f64 = 0.3;
    println!("\n  Пример: 0.1 + 0.2 == 0.3 ?");
    println!("    a = 0.1 + 0.2 = {:.20}", a);
    println!("    b = 0.3       = {:.20}", b);
    println!("    a == b: {} ❌", a == b);
    println!(
        "    (a - b).abs() < f64::EPSILON: {} ✅",
        (a - b).abs() < f64::EPSILON
    );

    println!("\nДругие константы точности:");
    println!(
        "  f32::DIGITS (десятичных цифр точности):     {}",
        f32::DIGITS
    );
    println!(
        "  f64::DIGITS (десятичных цифр точности):     {}",
        f64::DIGITS
    );
    println!(
        "  f32::MANTISSA_DIGITS (битов в мантиссе):    {}",
        f32::MANTISSA_DIGITS
    );
    println!(
        "  f64::MANTISSA_DIGITS (битов в мантиссе):    {}",
        f64::MANTISSA_DIGITS
    );

    // 5. Примеры потери точности
    println!("\n═══ Значащие цифры (DIGITS) ═══");

    println!("\nf32 (точность {} десятичных цифр):", f32::DIGITS);
    let f32_exact: f32 = 123456.0;
    let f32_more: f32 = 1234567.0;
    let f32_many: f32 = 123456789.0;
    println!("  6 цифр:  {} (точно)", f32_exact);
    println!("  7 цифр:  {} (округление)", f32_more);
    println!("  9 цифр:  {} (искажение)", f32_many);

    println!("\nf64 (точность {} десятичных цифр):", f64::DIGITS);
    let f64_exact: f64 = 123456789012345.0;
    let f64_more: f64 = 12345678901234567.0;
    let f64_many: f64 = 123456789012345678901.0;
    println!("  15 цифр: {} (точно)", f64_exact);
    println!("  17 цифр: {} (округление)", f64_more);
    println!("  21 цифра: {} (искажение)", f64_many);

    // Дробные числа
    println!("\nДробные (считаются ВСЕ значащие цифры):");
    let frac32: f32 = 1.2345678;
    let frac64: f64 = 1.234567890123456;
    println!("  f32 (хотели 1.2345678):");
    println!("    Получили: {:.10}", frac32);
    println!("  f64 (хотели 1.234567890123456):");
    println!("    Получили: {:.20}", frac64);

    // Отрицательные числа
    println!("\n═══ Дополнительные возможности ═══");
    let negative_float = -45.78;
    println!("Отрицательное число: {}", negative_float);

    // Специальные значения
    let infinity = f64::INFINITY;
    let neg_infinity = f64::NEG_INFINITY;
    let nan = f64::NAN; // Not a Number (результат 0.0 / 0.0)
    println!("\nСпециальные значения:");
    println!("  Бесконечность: {}", infinity);
    println!("  Минус бесконечность: {}", neg_infinity);
    println!("  NaN (Not a Number): {}", nan);
    println!("  1.0 / 0.0 = {}", 1.0 / 0.0);
    println!("  0.0 / 0.0 = {}", 0.0 / 0.0);

    // Диапазоны
    println!("\n═══ Диапазоны значений ═══");
    println!("f32::MIN: {:.2e}", f32::MIN);
    println!("f32::MAX: {:.2e}", f32::MAX);
    println!("f32::MIN_POSITIVE: {:.2e}", f32::MIN_POSITIVE);
    println!("\nf64::MIN: {:.2e}", f64::MIN);
    println!("f64::MAX: {:.2e}", f64::MAX);
    println!("f64::MIN_POSITIVE: {:.2e}", f64::MIN_POSITIVE);

    println!("\n📝 Рекомендации:");
    println!("  • f32 - для графики, игр (скорость важнее точности)");
    println!("  • f64 - для научных расчётов, финансов (нужна точность)");
    println!("  • Никогда не сравнивайте float на равенство напрямую!");
    println!("  • Используйте EPSILON для сравнения: (a - b).abs() < EPSILON");
}
