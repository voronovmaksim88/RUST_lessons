// ============================================================================
// КОНСТАНТЫ (const) В RUST — ПОДРОБНО
// ============================================================================
// Ключевые идеи:
// 1) const объявляются с обязательным типом: const NAME: Type = value;
// 2) Значение const должно быть известно на этапе компиляции
// 3) Имя пишут ЗАГЛАВНЫМИ_БУКВАМИ (конвенция)
// 4) const можно объявлять на глобальном уровне и внутри блоков
// 5) const не занимает фиксированное место в памяти (встраивается компилятором)
// ============================================================================

const PI: f64 = 3.141592653589793;
const MAX_USERS: usize = 100;
const TIMEOUT_MS: u64 = 5_000;
const SECONDS_IN_MINUTE: u64 = 60;
const SECONDS_IN_HOUR: u64 = 60 * SECONDS_IN_MINUTE;

// Константы часто используют для битовых флагов и масок.
const FLAG_READ: u8 = 1 << 0; // 0000_0001
const FLAG_WRITE: u8 = 1 << 1; // 0000_0010
const FLAG_EXECUTE: u8 = 1 << 2; // 0000_0100

// const fn — функция, которая может вычисляться на этапе компиляции.
// Важно: внутри const fn можно использовать только compile-time допустимые операции.
const fn kb_to_bytes(kb: usize) -> usize {
    kb * 1024
}

const BUFFER_SIZE: usize = kb_to_bytes(8); // 8 КБ

fn main() {
    println!("=== КОНСТАНТЫ В RUST ===\n");

    // ------------------------------------------------------------------------
    // 1. БАЗОВЫЕ КОНСТАНТЫ
    // ------------------------------------------------------------------------
    println!("1) Базовые константы:");
    println!("   PI = {}", PI);
    println!("   MAX_USERS = {}", MAX_USERS);
    println!("   TIMEOUT_MS = {}", TIMEOUT_MS);
    println!("   SECONDS_IN_MINUTE = {}", SECONDS_IN_MINUTE);
    println!("   SECONDS_IN_HOUR = {}", SECONDS_IN_HOUR);
    println!();

    // ------------------------------------------------------------------------
    // 2. КОНСТАНТЫ В ВЫЧИСЛЕНИЯХ
    // ------------------------------------------------------------------------
    println!("2) Константы в вычислениях:");
    let radius = 3.0;
    let area = PI * radius * radius;
    println!("   Площадь круга (r=3): {:.2}", area);

    let total_timeout = TIMEOUT_MS * 3;
    println!("   TIMEOUT_MS * 3 = {} ms", total_timeout);
    println!();

    // ------------------------------------------------------------------------
    // 3. КОНСТАНТЫ ВНУТРИ БЛОКА (ЛОКАЛЬНАЯ ОБЛАСТЬ ВИДИМОСТИ)
    // ------------------------------------------------------------------------
    println!("3) Локальная const внутри блока:");
    {
        const LOCAL_LIMIT: i32 = 10;
        println!("   LOCAL_LIMIT = {}", LOCAL_LIMIT);
    }
    println!();

    // ------------------------------------------------------------------------
    // 4. КОНСТАНТЫ ДЛЯ РАЗМЕРОВ МАССИВОВ
    // ------------------------------------------------------------------------
    println!("4) Константы для размеров массива:");
    const ROWS: usize = 2;
    const COLS: usize = 3;
    let matrix: [[i32; COLS]; ROWS] = [
        [1, 2, 3],
        [4, 5, 6],
    ];
    println!("   Матрица {}x{}: {:?}", ROWS, COLS, matrix);
    println!();

    // ------------------------------------------------------------------------
    // 5. КОНСТАНТЫ В MATCH
    // ------------------------------------------------------------------------
    println!("5) Константы в match:");
    const OK: u16 = 200;
    const NOT_FOUND: u16 = 404;
    let code = 404;
    let message = match code {
        OK => "OK",
        NOT_FOUND => "Not Found",
        _ => "Unknown",
    };
    println!("   Код {} -> {}", code, message);
    println!();

    // ------------------------------------------------------------------------
    // 6. БИТОВЫЕ ФЛАГИ С КОНСТАНТАМИ
    // ------------------------------------------------------------------------
    println!("6) Битовые флаги (const):");
    let mut permissions: u8 = 0;
    permissions |= FLAG_READ;
    permissions |= FLAG_WRITE;
    println!("   READ+WRITE: {:08b}", permissions);

    if permissions & FLAG_EXECUTE == 0 {
        println!("   EXECUTE не установлен");
    }
    println!();

    // ------------------------------------------------------------------------
    // 7. CONST FN И ВЫЧИСЛЕНИЯ НА ЭТАПЕ КОМПИЛЯЦИИ
    // ------------------------------------------------------------------------
    println!("7) const fn (compile-time вычисления):");
    println!("   BUFFER_SIZE = {} bytes", BUFFER_SIZE);
    println!();

    // ------------------------------------------------------------------------
    // 8. ВАЖНЫЕ ОГРАНИЧЕНИЯ
    // ------------------------------------------------------------------------
    println!("8) Ограничения const:");
    println!("   - const должны быть известны на этапе компиляции");
    println!("   - тип const обязателен");
    println!("   - нельзя использовать значения, вычисленные в runtime");
    println!();

    // Пример, который НЕ скомпилируется (оставлен как комментарий):
    // let runtime_value = 5;
    // const BAD: i32 = runtime_value; // ОШИБКА: runtime значение нельзя в const

    println!("=== Пример завершён ===");
}
