// ============================================================================
// УРОК 10: MATCH - СОПОСТАВЛЕНИЕ С ОБРАЗЦОМ
// ============================================================================
// Match - это мощный оператор сопоставления с образцом в Rust.
// Он похож на switch в других языках, но намного мощнее!
// ============================================================================

fn main() {
    println!("=== УРОК 10: MATCH ===\n");

    // ---------------------------------------------------------------------------
    // 1. БАЗОВОЕ ИСПОЛЬЗОВАНИЕ
    // ---------------------------------------------------------------------------
    println!("1. Базовое сопоставление:");
    let num = 2;
    match num {
        1 => println!("   один"),
        2 => println!("   два"),
        3 => println!("   три"),
        _ => println!("   другое число"),
    }

    // ---------------------------------------------------------------------------
    // 2. MATCH С ВОЗВРАТОМ ЗНАЧЕНИЯ
    // ---------------------------------------------------------------------------
    println!("\n2. Match возвращает значение:");
    let number = 5;
    let description = match number {
        1 => "единица",
        2 | 3 | 5 | 7 => "простое число (до 10)",
        4 | 6 | 8 | 10 => "чётное составное",
        _ => "другое",
    };
    println!("   Число {} - это {}", number, description);

    // ---------------------------------------------------------------------------
    // 3. ДИАПАЗОНЫ
    // ---------------------------------------------------------------------------
    println!("\n3. Использование диапазонов:");
    let age :u8 = 25;
    match age {
        0..=12 => println!("   Ребёнок (возраст: {})", age),
        13..=19 => println!("   Подросток (возраст: {})", age),
        20..=59 => println!("   Взрослый (возраст: {})", age),
        _ => println!("   Пожилой человек (возраст: {})", age),
    }

    // ---------------------------------------------------------------------------
    // 4. MATCH С ENUM
    // ---------------------------------------------------------------------------
    println!("\n4. Match с enum:");
    
    #[derive(Debug)]  // Автоматическая реализация трейта Debug для вывода
    #[allow(dead_code)]  // Разрешаем неиспользуемые варианты (для учебных целей)
    enum Direction {
        North,
        South,
        East,
        West,
    }
    
    let direction = Direction::North;
    match direction {
        Direction::North => println!("   Идём на север! ⬆"),
        Direction::South => println!("   Идём на юг! ⬇"),
        Direction::East => println!("   Идём на восток! ➡"),
        Direction::West => println!("   Идём на запад! ⬅"),
    }

    // ---------------------------------------------------------------------------
    // 5. ENUM С ДАННЫМИ
    // ---------------------------------------------------------------------------
    println!("\n5. Enum с данными:");
    
    #[allow(dead_code)]
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }
    
    let msg = Message::Move { x: 10, y: 20 };
    
    match msg {
        Message::Quit => println!("   Выход из программы"),
        Message::Move { x, y } => println!("   Перемещение в координаты x={}, y={}", x, y),
        Message::Write(text) => println!("   Запись текста: {}", text),
        Message::ChangeColor(r, g, b) => println!("   Смена цвета на RGB({}, {}, {})", r, g, b),
    }

    // ---------------------------------------------------------------------------
    // 6. MATCH С OPTION
    // Option<T> — это специальный enum в Rust для представления опциональных значений (значений, 
    // которые могут существовать или отсутствовать).
    // Это альтернатива null/nil из других языков, но безопасная на уровне типов.
    // ---------------------------------------------------------------------------
    println!("\n6. Match с Option:");
    
    let some_number: Option<i32> = Some(42);
    let no_number: Option<i32> = None;
    
    match some_number {
        Some(n) => println!("   Получено число: {}", n),
        None => println!("   Ничего не получено"),
    }
    
    match no_number {
        Some(n) => println!("   Получено число: {}", n),
        None => println!("   Ничего не получено"),
    }

    // ---------------------------------------------------------------------------
    // 7. MATCH С УСЛОВИЯМИ (GUARDS)
    // ---------------------------------------------------------------------------
    println!("\n7. Match с условиями (guards):");
    
    let pair = (5, -5); // это кортеж
    match pair {
        (x, y) if x == y => println!("   Числа равны: x = y = {}", x),
        (x, y) if x + y == 0 => println!("   Числа противоположны: {} и {}", x, y),
        (x, y) if x > y => println!("   {} больше чем {}", x, y),
        (x, y) => println!("   Просто пара чисел: ({}, {})", x, y),
    }

    // ---------------------------------------------------------------------------
    // 8. MATCH С RESULT
    // Result<T, E> — это специальный enum в Rust для представления результатов операций, 
    // которые могут завершиться успешно или с ошибкой.
    // Это альтернатива Exception из других языков, но безопасная на уровне типов.  
    // ---------------------------------------------------------------------------
    println!("\n8. Match с Result:");
    
    let result: Result<i32, &str> = Ok(200);
    
    match result {
        Ok(code) => println!("   Успех! Код: {}", code),
        Err(e) => println!("   Ошибка: {}", e),
    }

    // ---------------------------------------------------------------------------
    // 9. ВЛОЖЕННЫЕ СТРУКТУРЫ
    // ---------------------------------------------------------------------------
    println!("\n9. Сопоставление вложенных структур:");
    
    struct Point {
        x: i32,
        y: i32,
    }
    
    let point = Point { x: 0, y: 7 };
    
    match point {
        Point { x: 0, y: 0 } => println!("   Начало координат"),
        Point { x: 0, y } => println!("   На оси Y, координата y = {}", y),
        Point { x, y: 0 } => println!("   На оси X, координата x = {}", x),
        Point { x, y } => println!("   Произвольная точка ({}, {})", x, y),
    }


    // ---------------------------------------------------------------------------
    // 10. ПРАКТИЧЕСКИЙ ПРИМЕР: КАЛЬКУЛЯТОР
    // ---------------------------------------------------------------------------
    println!("\n11. Практический пример - калькулятор:");
    
    #[allow(dead_code)]
    enum Operation {
        Add(i32, i32),
        Subtract(i32, i32),
        Multiply(i32, i32),
        Divide(i32, i32),
    }
    
    let operation = Operation::Multiply(6, 7);
    
    let result = match operation {
        Operation::Add(a, b) => {
            println!("   Складываем {} + {}", a, b);
            a + b
        }
        Operation::Subtract(a, b) => {
            println!("   Вычитаем {} - {}", a, b);
            a - b
        }
        Operation::Multiply(a, b) => {
            println!("   Умножаем {} × {}", a, b);
            a * b
        }
        Operation::Divide(a, b) if b != 0 => {
            println!("   Делим {} ÷ {}", a, b);
            a / b
        }
        Operation::Divide(a, b) => {
            println!("   ⚠ Попытка деления {} на {}", a, b);
            println!("   ⚠ Деление на ноль невозможно!");
            0
        }
    };
    println!("   Результат: {}", result);

    println!("\n=== КОНЕЦ УРОКА ===");
}

// ============================================================================
// КЛЮЧЕВЫЕ МОМЕНТЫ:
// ============================================================================
// ✓ Match должен быть исчерпывающим (покрывать все случаи)
// ✓ _ используется как "catch-all" (поймать всё остальное)
// ✓ Match возвращает значение
// ✓ | позволяет объединять несколько паттернов
// ✓ if guards добавляют дополнительные условия
// ============================================================================
