fn main() {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║         ПОЛНОЕ РУКОВОДСТВО ПО ФУНКЦИЯМ В RUST                  ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    // ========================================================================
    // 1. ПРОСТЫЕ ФУНКЦИИ БЕЗ ПАРАМЕТРОВ
    // ========================================================================
    println!("╔═══ 1.1 Вызов функций без параметров ═══╗");
    hello();
    welcome();
    println!();

    // ========================================================================
    // 2. ФУНКЦИИ С ПАРАМЕТРАМИ И ПОБОЧНЫМИ ЭФФЕКТАМИ
    // ========================================================================
    println!("╔═══ 2.1 Функция с параметром и печатью ═══╗");
    square(5);
    println!();

    println!("╔═══ 2.2 Функция с несколькими параметрами ═══╗");
    show_user("John", 25);
    println!();

    // ========================================================================
    // 3. ВОЗВРАТ ЗНАЧЕНИЯ ИЗ ФУНКЦИИ
    // ========================================================================
    println!("╔═══ 3.1 Возврат значения (последнее выражение) ═══╗");
    let num = sum(10, 20);
    println!("  Сумма чисел 10 и 20 равна {}", num);
    println!();

    println!("╔═══ 3.2 Возврат через return ═══╗");
    let product = multiply(10, 20);
    println!("  Произведение чисел 10 и 20 равно {}", product);
    println!();

    println!("╔═══ 3.3 Возврат кортежа из функции ═══╗");
    let (min_v, max_v) = min_max(7, 3);
    println!("  min={}, max={}", min_v, max_v);
    println!();

    println!("╔═══ 3.4 Ранний выход из функции ═══╗");
    println!("  abs(-5) = {}", abs(-5));
    println!();

    // ========================================================================
    // 4. ССЫЛКИ, СРЕЗЫ И МУТАЦИЯ
    // ========================================================================
    println!("╔═══ 4.1 Передача по ссылке и срезы ═══╗");
    let nums = [1, 2, 3, 4, 5];
    println!("  Сумма массива = {}", sum_slice(&nums));
    println!();

    println!("╔═══ 4.2 Изменяемая ссылка (mut) ═══╗");
    let mut balance = 100;
    deposit(&mut balance, 50);
    println!("  Баланс после пополнения: {}", balance);
    println!();

    println!("╔═══ 4.3 Возврат ссылки и время жизни ═══╗");
    let a = "alpha";
    let b = "beta";
    println!("  Более длинная строка: {}", longest(a, b));
    println!();

    // ========================================================================
    // 5. ОБОБЩЕНИЯ (GENERICS)
    // ========================================================================
    println!("╔═══ 5.1 Обобщенная функция для разных типов ═══╗");
    println!("  max_i32 = {}", max_value(10, 25));
    println!("  max_f64 = {}", max_value(2.5, 1.7));
    println!();

    // ========================================================================
    // 6. ФУНКЦИИ КАК ЗНАЧЕНИЯ И ЗАМЫКАНИЯ
    // ========================================================================
    println!("╔═══ 6.1 Передача функции как параметра ═══╗");
    println!("  apply(6, square_value) = {}", apply(6, square_value));
    println!();

    println!("╔═══ 6.2 Замыкание (closure) ═══╗");
    let add_two = |x: i32| x + 2;
    println!("  add_two(7) = {}", add_two(7));
    println!();

    println!("╔═══ 6.3 Использование функции как значения ═══╗");
    let op: fn(i32, i32) -> i32 = sum;
    println!("  op(3, 4) = {}", op(3, 4));
    println!();

    println!("╔═══ 6.4 Функция как результат другой функции ═══╗");
    let operation1 = choose_operation(1);
    operation1(5, 4);

    let operation2 = choose_operation(2);
    operation2(5, 4);

    let operation3 = choose_operation(3);
    operation3(5, 4);
    println!();

    println!("╔═══Тема 6.5 Суммирование по условию (предикат)═══╗");
    let values = [1, 2, 3, 4, 5];
    let even_sum = sum_by(&values, is_even);
    println!("  sum_by even = {}", even_sum);
    println!();

    // ========================================================================
    // РЕЗЮМЕ
    // ========================================================================
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║                         РЕЗЮМЕ                                 ║");
    println!("╠════════════════════════════════════════════════════════════════╣");
    println!("║ • fn          - объявление функции                             ║");
    println!("║ • параметры   - типы обязательны                               ║");
    println!("║ • -> T        - тип возвращаемого значения                     ║");
    println!("║ • return      - явный возврат                                  ║");
    println!("║ • & и &mut    - ссылки и мутабельные ссылки                    ║");
    println!("║ • generics    - обобщенные функции                             ║");
    println!("║ • fn(...)     - тип функции                                    ║");
    println!("║ • closure     - анонимная функция                              ║");
    println!("╚════════════════════════════════════════════════════════════════╝");

    println!("\n✅ Урок по функциям в Rust завершён!");
}

// Функция без параметров и без возвращаемого значения.
fn hello() {
    println!("Hello!");
}

// Еще одна простая функция.
fn welcome() {
    println!("Welcome to Rust World!");
}

// Параметры функции имеют типы.
fn square(n: i32) {
    let result = n * n;
    println!("Квадрат числа {} равен {}", n, result);
}

// Несколько параметров разных типов.
fn show_user(name: &str, age: i32) {
    println!("Информация о пользователе");
    println!("Имя: {}", name);
    println!("Возраст: {}", age);
}

// Возврат значения: тип указывается после ->
fn sum(a: i32, b: i32) -> i32 {
    a + b // последнее выражение — результат
}

// Возврат через return, полезно при раннем выходе.
fn multiply(a: i32, b: i32) -> i32 {
    return a * b;
}

// Возврат кортежа из функции.
fn min_max(a: i32, b: i32) -> (i32, i32) {
    if a < b { (a, b) } else { (b, a) }
}

// Пример раннего выхода.
fn abs(x: i32) -> i32 {
    if x >= 0 {
        return x;
    }
    -x
}

// Срез массива: принимаем ссылку на последовательность.
fn sum_slice(values: &[i32]) -> i32 {
    let mut total = 0;
    for v in values {
        total += v;
    }
    total
}

// Изменяемая ссылка позволяет менять данные вызывающей стороны.
fn deposit(balance: &mut i32, amount: i32) {
    *balance += amount;
}

// Возврат ссылки: ссылка живет столько же, сколько входные данные.
fn longest<'a>(a: &'a str, b: &'a str) -> &'a str {
    if a.len() >= b.len() { a } else { b }
}

// Обобщенная (generic) функция с ограничением PartialOrd + Copy.
fn max_value<T: PartialOrd + Copy>(a: T, b: T) -> T {
    if a >= b { a } else { b }
}

// Функция, принимающая другую функцию как параметр.
fn apply(value: i32, f: fn(i32) -> i32) -> i32 {
    f(value)
}

// Обычная функция подходит там, где ожидается fn(i32) -> i32.
fn square_value(x: i32) -> i32 {
    x * x
}

// Возвращает выбранную операцию как функцию.
fn choose_operation(n: i32) -> fn(i32, i32) {
    match n {
        1 => |a, b| { println!("{}", a + b); },
        2 => multiply_print,
        _ => |a, b| { println!("a={}  b={}", a, b); },
    }
}

fn multiply_print(a: i32, b: i32) {
    println!("{}", a * b);
}

// Суммирует значения, которые удовлетворяют предикату; предикат имеет сигнатуру fn(i32) -> bool.
fn sum_by(values: &[i32], predicate: fn(i32) -> bool) -> i32 {
    let mut total = 0;
    for &v in values {
        if predicate(v) {
            total += v;
        }
    }
    total
}

fn is_even(x: i32) -> bool {
    x % 2 == 0
}
