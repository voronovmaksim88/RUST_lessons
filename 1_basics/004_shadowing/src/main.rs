fn main() {
    // ЗАТЕНЕНИЕ (SHADOWING) в Rust

    // 1. Основы затенения: можно объявлять переменные с тем же именем
    // Первоначальное объявление переменной
    let number: u8 = 1;
    println!("1. Исходное значение number (u8): {}", number);

    // Затенение переменной - переобъявление с тем же именем
    // Обратите внимание, что тип изменился с u8 на i8
    let number: i8 = 2;
    println!("2. После первого затенения number (i8): {}", number);

    // Затенение с использованием предыдущего значения
    // Берём текущее значение number (2) и добавляем 1
    let number: i8 = number + 1;
    println!("3. После второго затенения number (i8): {}", number);

    // 2. Затенение VS изменяемые переменные
    println!("\n=== Затенение vs mut ===");

    // Затенение позволяет менять тип переменной
    let value = "строка";
    println!("4. Изначальный value (строка): {}", value);

    let value = value.len(); // Преобразуем строку в число (её длину)
    println!("5. После затенения value (число): {}", value);

    // С mut нельзя менять тип переменной:
    // Следующий код НЕ скомпилируется:
    // let mut x = "строка";
    // x = x.len(); // Ошибка! Нельзя присвоить число переменной типа строка

    // 3. Область видимости и затенение
    println!("\n=== Область видимости и затенение ===");

    let scope_test = 10;
    println!("6. scope_test снаружи блока: {}", scope_test);

    {
        // Затенение в новом блоке
        let scope_test = "внутри блока";
        println!("7. scope_test внутри блока: {}", scope_test);

        // Ещё одно затенение в том же блоке
        let scope_test = true;
        println!("8. scope_test после второго затенения: {}", scope_test);
    } // Здесь внутренние затенения scope_test перестают существовать

    // За пределами блока внутреннее затенение не действует
    println!("9. scope_test снова снаружи: {}", scope_test);

    // 4. Затенение с использованием в выражениях
    println!("\n=== Затенение в выражениях ===");

    let calculation = {
        let x = 5;
        let x = x * 2; // Затенение x
        x // Возвращаем значение x
    };
    println!("10. Результат вычисления: {}", calculation);

    // 5. Практический пример: обработка данных
    println!("\n=== Практический пример ===");

    let user_input = "   42   ";
    println!("11. Исходные данные: '{}'", user_input);

    // Цепочка затенений для обработки данных
    let user_input = user_input.trim(); // Убираем пробелы
    println!("12. После trim(): '{}'", user_input);

    let user_input = user_input.parse::<i32>().unwrap(); // Преобразуем в число
    println!("13. После parse() (i32): {}", user_input);

    let user_input = user_input * 2; // Умножаем на 2
    println!("14. После умножения: {}", user_input);

    // ИТОГО:
    // 1. Затенение позволяет повторно использовать имя переменной
    // 2. При затенении можно изменить тип переменной (в отличие от mut)
    // 3. Затенение действует в рамках области видимости
    // 4. Затенение полезно для пошаговой обработки данных
    // 5. В отличие от mut, затенение создаёт новую переменную (а не изменяет существующую)
}
