fn main() {
    // =========================================================================
    // Пример: вывод переменных в консоль (максимально подробно)
    // =========================================================================
    //
    // В Rust:
    // - переменные по умолчанию НЕИЗМЕНЯЕМЫЕ (immutable);
    // - чтобы сделать переменную изменяемой, нужно писать `mut`;
    // - у переменных есть тип, который можно:
    //   - указать явно (аннотация типа), или
    //   - доверить компилятору вывести (type inference).
    //
    // Для вывода текста в консоль чаще всего используют:
    // - `println!()` — печатает строку и переводит курсор на новую строку
    // - `print!()`   — печатает без перевода строки (здесь не используем)
    //
    // Важно: `println!` — это МАКРОС, а не функция. Макросы в Rust пишутся с `!`.
    // Макрос подставляет код во время компиляции, поэтому форматирование происходит
    // эффективно и с проверками типов.
    //
    // ----------------------------------------------------------------------------
    // 1) Неизменяемая переменная с явной аннотацией типа
    // ----------------------------------------------------------------------------

    // `age` — неизменяемая переменная типа `u8` (целое без знака, 0..=255).
    // Здесь тип указан явно после двоеточия: `age: u8`.
    // Значение 37 подходит для `u8`, поэтому всё корректно.
    let age: u8 = 37;

    // `println!` использует формат-строку.
    // `{}` — "плейсхолдер" (placeholder) для значения, которое будет подставлено.
    // После строки идут аргументы: сюда передаём `age`.
    //
    // Внутри `{}` используется трейт `Display` (человекочитаемый вывод).
    println!("My age is {}", age);

    // ----------------------------------------------------------------------------
    // 2) Переменная со строковым литералом и вывод нескольких значений
    // ----------------------------------------------------------------------------

    // `name` — это строковый литерал (тип `&'static str`).
    //
    // Важная разница:
    // - `&str` — "срез строки" (borrowed string slice), обычно это ссылка на уже
    //   существующие данные (часто на литерал в коде).
    // - `String` — "владельческая" строка, лежит в куче и может изменяться.
    //
    // Здесь мы используем литерал, поэтому `&'static str`.
    let name = "Maksim";

    // Можно подставлять несколько значений:
    // первый `{}` — это `name`, второй `{}` — это `age`.
    //
    // Обрати внимание: в Rust в строковых литералах обычно используют обычный `'`
    println!("My name is {}. I'm {} years old.", name, age);

    // ----------------------------------------------------------------------------
    // 3) Именованные аргументы форматирования
    // ----------------------------------------------------------------------------
    //
    // Вместо позиционных `{}` можно использовать именованные `{name}` и `{age}`.
    // Это делает форматирование читабельнее, особенно когда аргументов много.
    println!("(named args) name={name}, age={age}");

    // ----------------------------------------------------------------------------
    // 4) Отладочный вывод (Debug)
    // ----------------------------------------------------------------------------
    //
    // `{}` требует `Display`, но далеко не все типы его реализуют.
    // Для отладочного вывода используется `{:?}` (требуется трейт `Debug`).
    // Большинство базовых типов и многие структуры его имеют.
    //
    // Пример: выведем кортеж (tuple).
    let pair = (name, age);
    println!("(debug) pair = {:?}", pair);

    // ----------------------------------------------------------------------------
    // 5) Изменяемая переменная (`mut`) и вычисления
    // ----------------------------------------------------------------------------
    //
    // Если нужно менять значение переменной, обязательно указываем `mut`.
    // Здесь `year` — изменяемая переменная, тип компилятор выведет сам (будет i32).
    let mut year = 2025;

    // Изменяем значение.
    year += 1;

    // В форматировании можно задавать ширину/выравнивание:
    // - `{:<6}` — выравнивание по левому краю, ширина 6
    // - `{:>6}` — по правому краю
    // - `{:^6}` — по центру
    println!("year left-aligned : '{:<6}'", year);
    println!("year right-aligned: '{:>6}'", year);
    println!("year centered     : '{:^6}'", year);

    // ----------------------------------------------------------------------------
    // 6) Теневое переопределение (shadowing)
    // ----------------------------------------------------------------------------
    //
    // Rust позволяет объявить переменную с тем же именем повторно через `let`.
    // Это НЕ то же самое, что `mut`:
    // - `mut` меняет значение той же переменной;
    // - shadowing создаёт новую переменную (возможно, даже другого типа),
    //   скрывая старую в текущей области видимости.
    //
    // Пример: пусть `age` в виде числа, а затем сделаем строку с тем же именем.
    let age = age as u16; // новая `age` (u16), старая `age` (u8) теперь скрыта
    let age = format!("{age}"); // теперь `age` — String

    // Выведем результат:
    println!("(shadowing) age is now a String: '{age}'");

    // ----------------------------------------------------------------------------
    // 7) Небольшое резюме
    // ----------------------------------------------------------------------------
    //
    // - `println!("... {}", x)` — форматированный вывод через Display
    // - `println!("... {:?}", x)` — отладочный вывод через Debug
    // - переменные по умолчанию immutable, для изменения нужен `mut`
    // - shadowing через `let` позволяет "перезаписать" имя новой переменной
    // - строковые литералы имеют тип `&'static str`, а `String` владеет данными
}
